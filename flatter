#!/usr/bin/env python3

################################################################################
# The MIT License (MIT)

# Copyright (c) 2020 J. Brian Lee

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
################################################################################

try:
    import tkinter as tk
except ModuleNotFoundError:
    sys.exit('error: tkinter not found. You may need to "pip install tk".')

import collections
import configparser
import os
import subprocess
import sys

import tkinter.filedialog


def exec_proc(cmd, capture_output=True):
    sys.stdout.flush()
    sys.stderr.flush()

    shell = type(cmd) == str

    if capture_output:
        p = subprocess.Popen(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        out, err = p.communicate()
        out = out.decode('utf-8').strip()
        err = err.decode('utf-8').strip()
        return p.returncode, out, err
    else:
        return subprocess.call(cmd, shell=shell)


def get_home_dir():
    # posix
    if 'HOME' in os.environ:
        return os.environ['HOME']
    # windows
    elif 'HOMEPATH' in os.environ:
        drive = os.environ['HOMEDRIVE'] if 'HOMEDRIVE' in os.environ else ''
        path = os.environ['HOMEPATH']
        return os.path.join(drive, path)
    # ???
    else:
        return os.path.abspath('.')


class Flatter:
    def __init__(self):
        self.home_dir = get_home_dir()
        self.last_path = self.home_dir
        self.recent_paths = []
        self.read_config()

    def get_last_path(self):
        return self.last_path

    def set_last_path(self, p):
        if not p:
            return

        self.last_path = p
        if p in self.recent_paths:
            self.recent_paths.remove(p)
        self.recent_paths.insert(0, p)
        self.recent_paths = self.recent_paths[:20]
        print(self.recent_paths)

    def get_recent_paths(self):
        return self.recent_paths[:]

    def read_config(self):
        if not self.home_dir:
            return

        cfg_file_name = os.path.join(self.home_dir, '.flatter')
        config = configparser.ConfigParser()
        config.read(cfg_file_name)

        if config.has_section('paths'):
            self.last_path = config.get(
                'paths', 'last_path', fallback=self.last_path)

            recents = [item for item in config.items('paths')
                if item[0].startswith('recent_path_')]
            recents.sort(key=lambda pair : pair[0])
            self.recent_paths = [item[1] for item in recents]

    def write_config(self):
        if not self.home_dir:
            return

        paths = collections.OrderedDict()
        if self.last_path:
            paths['last_path'] = self.last_path

        idx = 0
        for recent_path in self.recent_paths:
            key = 'recent_path_%02d' % idx
            paths[key] = recent_path
            idx += 1

        cfg = collections.OrderedDict()
        cfg['paths'] = paths

        config = configparser.ConfigParser()
        config.read_dict(cfg)

        cfg_file_name = os.path.join(self.home_dir, '.flatter')
        with open(cfg_file_name, 'w') as configfile:
            config.write(configfile)

    def open_dir(self, path):
        print('opening', path)
        self.set_last_path(path)
        self.write_config()
        return True


class FlatterFrame(tk.Frame):
    def __init__(self, parent=None):
        tk.Frame.__init__(self, parent)

        self.pack(expand=tk.YES, fill=tk.BOTH)            # make me expandable

        self.init_canvas()

    def init_canvas(self):
        canvas = tk.Canvas(self, bg='dark grey')
        # canvas.config(scrollregion=(0, 0, 500, 500))      # canvas size corners
        canvas.config(highlightthickness=0)               # no pixels to border

        vertical = tk.Scrollbar(self)
        vertical.config(command=canvas.yview)             # xlink sbar and canv
        canvas.config(yscrollcommand=vertical.set)        # move one moves other
        vertical.pack(side=tk.RIGHT, fill=tk.Y)           # pack first=clip last

        horizontal = tk.Scrollbar(self, orient=tk.HORIZONTAL)
        horizontal.config(command=canvas.xview)           # xlink sbar and canv
        canvas.config(xscrollcommand=horizontal.set)      # move one moves other
        horizontal.pack(side=tk.BOTTOM, fill=tk.X)        # pack first=clip last

        canvas.pack(side=tk.LEFT, expand=tk.YES, fill=tk.BOTH) # canv clipped first

        self.canvas = canvas


class FlatterWin:
    def __init__(self, root=None):
        if root is None:
            root = tk.Tk()
        self.root = root
        self.flatter = Flatter()

        root.wm_title('Flatter!')

        w = root.winfo_screenwidth() / 2
        h = root.winfo_screenheight() / 2
        root.geometry('%dx%d' % (w, h))

        root.protocol('WM_DELETE_WINDOW', self.on_destroy)

        self.init_menu()

        FlatterFrame(root)

        root.mainloop()

    def on_destroy(self):
        self.root.destroy()
        sys.exit()

    def init_menu(self):
        menu_bar = tk.Menu(self.root)
        file_menu = tk.Menu(menu_bar, tearoff=0)
        file_menu.add_command(label='Open Repo', command=self.ask_open_dir)
        open_recents_menu = tk.Menu(file_menu, tearoff=0)
        file_menu.add_cascade(label='Open Recent', menu=open_recents_menu)
        file_menu.add_separator()
        file_menu.add_command(label='Exit', command=self.on_destroy)

        menu_bar.add_cascade(label='File', menu=file_menu)

        self.root.config(menu=menu_bar)
        self.file_menu = file_menu
        self.open_recents_menu = open_recents_menu

        self.update_open_recent_menu()

    def update_open_recent_menu(self):
        self.open_recents_menu.delete(0, 'end')

        recents = self.flatter.get_recent_paths()
        state = 'normal' if recents else 'disabled'
        self.file_menu.entryconfig('Open Recent', state=state)

        if not recents:
            return

        # generator fn to correcty capture value of "recent" in closure
        def make_cmd():
            recent2 = recent
            return lambda: self.open_dir(recent2)

        for recent in recents:
            self.open_recents_menu.add_command(
                label=recent,
                command=make_cmd())


    def ask_open_dir(self):
        path = tk.filedialog.askdirectory(initialdir=get_home_dir())
        if path:
            self.open_dir(path)


    def open_dir(self, path):
        if not path:
            return

        if not self.flatter.open_dir(path):
            return

        self.update_open_recent_menu()


if __name__ == '__main__':
    FlatterWin()
