#!/usr/bin/env python3

################################################################################
# The MIT License (MIT)

# Copyright (c) 2020 J. Brian Lee

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
################################################################################

try:
    import tkinter as tk
except ModuleNotFoundError:
    sys.exit('error: tkinter not found. You may need to "pip install tk".')

import collections
import configparser
import enum
import math
import os
import pprint
import re
import subprocess
import sys

import tkinter.filedialog
import tkinter.font
import tkinter.messagebox
import tkinter.ttk as ttk


class CommitDirection(enum.Enum):
    MATCHES = 1
    AHEAD = 2
    BEHIND = 3
    ADJACENT = 4
    MISSING = 5
    NONE = 6


class Result:
    def __init__(self, val=None, err=None):
        self._val = val
        self._err = err

    def __bool__(self):
        return not bool(self._err)

    def get_val(self):
        if self._err:
            raise RuntimeError('Getting Result value from error Result')
        return self._val

    def get_err(self):
        return self._err

    def error(err):
        return Result(None, err)


class DoInExistingDir(object):
    def __init__(self, path):
        self._old_dir = os.getcwd()
        self._new_dir = path

    def __enter__(self):
        try:
            os.chdir(self._new_dir)
            return self
        except:
            return None

    def __exit__(self, type, value, traceback):
        os.chdir(self._old_dir)
        return isinstance(value, OSError)

def exec_proc(cmd, capture_output=True, console=None):
    sys.stdout.flush()
    sys.stderr.flush()

    shell = type(cmd) == str

    if console:
        cmd_txt = cmd if shell else ' '.join(cmd)
        console.write('exec cmd: ' + cmd_txt)

    if capture_output:
        p = subprocess.Popen(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        out, err = p.communicate()
        out = out.decode('utf-8')
        err = err.decode('utf-8')
        return p.returncode, out, err
    else:
        return subprocess.call(cmd, shell=shell)


def remove_commit_descr_prefix(descr):
    if descr.startswith('heads/'):
        descr = descr[len('heads/'):]
    elif descr.startswith('remotes/'):
        descr = descr[len('remotes/'):]
    return descr


def is_descendant_of(w, other):
    if not w:
        return False

    if w == other:
        return True

    return is_descendant_of(w.master, other)


def get_lines(text):
    lines = text.split('\n') if text else []
    if lines and lines[-1] == '':
        lines = lines[:-1]
    # lines = [line.strip() for line in lines]
    return lines


def get_home_dir():
    # posix
    if 'HOME' in os.environ:
        return os.environ['HOME']
    # windows
    elif 'HOMEPATH' in os.environ:
        drive = os.environ['HOMEDRIVE'] if 'HOMEDRIVE' in os.environ else ''
        path = os.environ['HOMEPATH']
        return os.path.join(drive, path)
    # ???
    else:
        return os.path.abspath('.')


def make_git_err_msg(cmd, out, err):
    if type(cmd) == list:
        cmd = ' '.join(cmd)
    err_str = \
        'git cmd failed: \"' + cmd + '\"\n' \
        '  out: ' + out + '\n' \
        '  err: ' + err
    return Result.error(err_str)


def get_git_hash(ref):
    cmd = ['git', 'rev-parse', ref]
    (ret, out, err) = exec_proc(cmd)
    if ret == 0:
        return Result(out.strip())
    else:
        return make_git_err_msg(cmd, out, err)


def get_submodule_status(cached, console=None):
    cmd = 'git submodule status --recursive'
    if cached:
        cmd += ' --cached'
    (ret, out, err) = exec_proc(cmd, console=console)
    if ret == 0:
        return Result(get_lines(out))
    else:
        return make_git_err_msg(cmd, out, err)


def get_git_remotes(console=None):
    cmd = 'git remote'
    (ret, out, err) = exec_proc(cmd, console=console)
    if ret == 0:
        return Result(get_lines(out.strip()))
    else:
        return make_git_err_msg(cmd, out, err)


def fetch_git_remote(remote, console=None):
    cmd = ['git', 'fetch', remote]
    (ret, out, err) = exec_proc(cmd, console=console)
    if ret == 0:
        return Result()
    else:
        return make_git_err_msg(cmd, out, err)


def get_subs_from_gitmodules(treeish, console=None):
    sub_info = {}

    cmd = ['git', 'ls-tree', treeish, '.gitmodules']
    (ret, out, err) = exec_proc(cmd, console=console)
    if ret == 0:
        if not out.strip():
            return Result(sub_info)
    else:
        return make_git_err_msg(cmd, out, err)

    cmd = 'git config -l --blob %s:.gitmodules' % treeish
    (ret, out, err) = exec_proc(cmd, console=console)
    if ret == 0:
        for line in get_lines(out.strip()):
            parts = line.split('=', 1)
            if len(parts) < 2:
                continue
            (var, val) = line.split('=', 1)
            parts = var.split('.', 2)
            if (len(parts) != 3
                or parts[0] != 'submodule'
                or parts[2] != 'path'):

                continue
            name = os.path.basename(parts[1])
            path = val
            sub_info[name] = path
        return Result(sub_info)
    else:
        return make_git_err_msg(cmd, out, err)


def get_submodule_commit(treeish, sub_path, console=None):
    cmd = ['git', 'ls-tree', treeish, sub_path]
    (ret, out, err) = exec_proc(cmd, console=console)
    if ret == 0:
        parts = out.split()
        if len(parts) < 4 or parts[1] != 'commit':
            return Result.error('bad output for git ls-tree:\n  ' + out)
        return Result(parts[2])
    else:
        return make_git_err_msg(cmd, out, err)


def get_commit_exists(commit, console=None):
    commit_spec = '%s^{commit}' % commit
    cmd = ['git', 'cat-file', '-e', commit_spec]
    (ret, out, err) = exec_proc(cmd, console=console)
    return ret == 0


def get_commit_is_ancestor(commit1, commit2, console=None):
    cmd = ['git', 'merge-base', '--is-ancestor', commit1, commit2]
    (ret, out, err) = exec_proc(cmd, console=console)
    if ret == 0:
        return Result(True)
    elif ret == 1:
        return Result(False)
    else:
        return make_git_err_msg(cmd, out, err)


class Submodule:
    def __init__(self,
        name, path,
        indexed_hash, checked_out_hash,
        indexed_descr, checked_out_descr,
        initialized, derived,
        merge_conflicts):

        self.name = name
        self.path = path
        self.indexed_hash = indexed_hash
        self.checked_out_hash = checked_out_hash
        self.indexed_descr = indexed_descr
        self.checked_out_descr = checked_out_descr
        self.initialized = initialized
        self.derived = derived
        self.merge_conflicts = merge_conflicts
        self.is_top_level = False
        self.missing_at_top = False
        self.relation_to_top_indexed = CommitDirection.NONE
        self.relation_to_top_checked_out = CommitDirection.NONE
        self.subs = []

    def add_sub(self, sub):
        self.subs.append(sub)


class Flatter:
    def __init__(self, console):
        self._is_open = False
        self._home_dir = get_home_dir()
        self._last_path = self._home_dir
        self._recent_paths = []
        self._root_sub = self.create_root_sub()
        self._top_subs = {}
        self._console = console
        self.read_config()

    def write_console(self, text):
        if self._console:
            self._console.write(text)
        else:
            print(text)

    def get_is_open(self):
        return self._is_open

    def create_root_sub(self):
        return Submodule(
            name='', path='',
            indexed_hash='', checked_out_hash='',
            indexed_descr='', checked_out_descr='',
            initialized=False, derived=False,
            merge_conflicts=False)

    def get_last_path(self):
        return self._last_path

    def set_last_path(self, path):
        if not path:
            return

        self._last_path = path
        if path in self._recent_paths:
            self._recent_paths.remove(path)
        self._recent_paths.insert(0, path)
        self._recent_paths = self._recent_paths[:20]

    def get_recent_paths(self):
        return self._recent_paths[:]

    def get_root_sub(self):
        return self._root_sub

    def get_sub_depth(self):
        def do_get_sub_depth(sub):
            if len(sub.subs) == 0:
                return 0
            return max([do_get_sub_depth(child) for child in sub.subs]) + 1

        return do_get_sub_depth(self._root_sub)

    def remove_recent(self, path):
        if path in self._recent_paths:
            self._recent_paths.remove(path)
            self.write_config()

    def read_config(self):
        if not self._home_dir:
            return

        cfg_file_name = os.path.join(self._home_dir, '.flatter')
        config = configparser.ConfigParser()
        config.read(cfg_file_name)

        if config.has_section('paths'):
            self._last_path = config.get(
                'paths', 'last_path', fallback=self._last_path)

            recents = [item for item in config.items('paths')
                if item[0].startswith('recent_path_')]
            recents.sort(key=lambda pair : pair[0])
            self._recent_paths = [item[1] for item in recents]

    def write_config(self):
        if not self._home_dir:
            return

        paths = collections.OrderedDict()
        if self._last_path:
            paths['last_path'] = self._last_path

        idx = 0
        for recent_path in self._recent_paths:
            key = 'recent_path_%02d' % idx
            paths[key] = recent_path
            idx += 1

        cfg = collections.OrderedDict()
        cfg['paths'] = paths

        config = configparser.ConfigParser()
        config.read_dict(cfg)

        cfg_file_name = os.path.join(self._home_dir, '.flatter')
        with open(cfg_file_name, 'w') as configfile:
            config.write(configfile)

    def insert_new_sub(self, root_sub, new_sub):
        for sub in root_sub.subs:
            if new_sub.path.startswith(sub.path + '/'):
                self.insert_new_sub(sub, new_sub)
                return
        self.write_console('adding sub: %s' % new_sub.name)
        root_sub.add_sub(new_sub)

    def build_submodule_tree(self):
        result = get_submodule_status(cached=True, console=self._console)
        if not result:
            return result
        indexed_subs = result.get_val()

        result = get_submodule_status(cached=False, console=self._console)
        if not result:
            return result
        checked_out_subs = result.get_val()

        if len(indexed_subs) != len(checked_out_subs):
            return Result.error(
                'indexed and checked out submodule lists were not the ' \
                'same length')

        root_sub = self.create_root_sub()
        added_subs = []

        i = 0
        while i < len(indexed_subs):
            indexed_sub = indexed_subs[i]
            checked_out_sub = checked_out_subs[i]
            if not indexed_sub:
                return Result.error('indexed submodule line was empty')
            if not checked_out_sub:
                return Result.error('checked out submodule line was empty')
            if indexed_sub[0] != checked_out_sub[0]:
                return Result.error(
                    'submodule lines aren\' compatible; ' \
                    'first characters must match.\n' \
                    '    indexed: %s\n' \
                    'checked out: %s\n' % \
                    (indexed_sub, checked_out_sub))

            initialized = indexed_sub[0] != '-'
            merge_conflicts = indexed_sub[0] != 'U'

            indexed_sub = indexed_sub[1:].split(' ')
            checked_out_sub = checked_out_sub[1:].split(' ')

            if len(indexed_sub) < 2:
                return Result.error('indexed submodule line too short')
            if len(checked_out_sub) < 2:
                return Result.error('checked out submodule line too short')

            indexed_hash = indexed_sub[0]
            checked_out_hash = checked_out_sub[0]

            if indexed_sub[1] != checked_out_sub[1]:
                return Result.error(
                    'sub paths didn\'t match:\n' \
                    '  "%s" != "%s"' % (indexed_sub[1], checked_out_sub[1]))

            sub_path = indexed_sub[1]
            sub_name = os.path.basename(sub_path)

            indexed_descr = ''
            if len(indexed_sub) >= 3:
                indexed_descr = indexed_sub[2]
                indexed_descr = re.sub(r'^\(', '', indexed_descr)
                indexed_descr = re.sub(r'\)$', '', indexed_descr)

            checked_out_descr = ''
            if len(checked_out_sub) >= 3:
                checked_out_descr = checked_out_sub[2]
                checked_out_descr = re.sub(r'^\(', '', checked_out_descr)
                checked_out_descr = re.sub(r'\)$', '', checked_out_descr)

            new_sub = Submodule(
                name=sub_name,
                path=sub_path,
                indexed_hash=indexed_hash,
                checked_out_hash=checked_out_hash,
                indexed_descr=indexed_descr,
                checked_out_descr=checked_out_descr,
                initialized=initialized,
                derived=False,
                merge_conflicts=merge_conflicts)
            self.insert_new_sub(root_sub, new_sub)
            added_subs.append(new_sub)

            i += 1

        self._root_sub = root_sub;
        self._top_subs = dict([(sub.name, sub) for sub in self._root_sub.subs])

        return Result()

    def do_open_dir(self, path):
        if not path or not type(path) is str:
            return Result.error('bad path: "%s"' % str(path))

        git_status_cmd = 'git status'
        (ret, out, err) = exec_proc(git_status_cmd)
        if ret != 0:
            return Result.error(err)

        lines = get_lines(out)
        if not lines:
            err_txt = 'git status didn\'t return anything in path: %s' % path
            return Result.error(err_txt)

        detatched_marker = 'HEAD detached at '
        branch_marker = 'On branch '
        if lines[0].startswith(detatched_marker):
            branch = lines[0]
            commit = lines[0][len(detatched_marker):]
        elif lines[0].startswith(branch_marker):
            branch = lines[0][len(branch_marker):]
            commit_result = get_git_hash('HEAD')
            if not commit_result:
                return commit_result
            commit = commit_result.get_val()
        else:
            err_txt = (
                'bad git output:\n' +
                '  out: %s\n' +
                '  err: %s\n') % out, err
            return make_git_err_msg(git_status_cmd, out, err)

        self.write_console(
            'successfully opened path: %s\n'
            '  branch: %s\n'
            '  commit: %s\n' %
            (path, branch, commit))

        result = self.build_submodule_tree()
        if result:
            self._is_open = True
            self.set_last_path(path)
            self.write_config()
            self.derive_uninitialized_repos()
            self.calc_stats_recursive(self._root_sub)

        return result

    def open_dir(self, path):
        with DoInExistingDir(path) as ctx:
            if ctx:
                return self.do_open_dir(path)
            else:
                return Result.error('missing repo: %s' % path)

    def fetch_submodule(self):
        result = get_git_remotes(console=self._console)
        if not result:
            self._console.write(
                'Error getting remotes for submodule:\n'
                '  %s' % result.get_err())
            return result

        remotes = result.get_val()
        if remotes:
            self._console.write('Found remote(s): ' + ', '.join(remotes))
        else:
            self._console.write('Found no remotes.')

        had_err = False
        for remote in remotes:
            result = fetch_git_remote(remote, console=self._console)
            if not result:
                had_err = True
                self._console.write(
                    'Error fetching submodule:\n'
                    '  %s' % result.get_err())

        return Result() if not had_err else Result('Error fetching submodule')

    def fetch_immediate_submodules(self):
        if not self._is_open:
            return

        had_err = False
        for sub in self._root_sub.subs:
            path = os.path.join(self._last_path, sub.path)
            self._console.write('Entering directory: ' + path)
            with DoInExistingDir(path) as ctx:
                if ctx:
                    if not self.fetch_submodule():
                        had_err = True
                else:
                    had_err = True
                    self._console.write(
                        'Could not switch to directory %s '
                        'for submodule %s\n' % (sub.path, sub.name))

        return (Result() if not had_err else
            Result.error('Errors encountered fetching submodules.'))

    def sub_exists_at_top_level(self, sub):
        return sub.name in self._top_subs.keys()

    def create_derived_repo_children(self, submodule):
        sub_info = get_subs_from_gitmodules(
            submodule.indexed_hash, console=self._console)
        if not sub_info:
            self._console.write(
                'Couldn\'t get submodule info for submodule '
                '%s\n:  err: %s' % (submodule.name, sub_info.get_err()))
            return

        for (sub_sub_name, sub_sub_path) in sub_info.get_val().items():
            sub_hash = get_submodule_commit(
                submodule.indexed_hash, sub_sub_path, console=self._console)
            if not sub_hash:
                self._console.write(
                    'Could not switch to directory %s for submodule %s\n'
                    % (path, submodule.name))
                continue

            new_sub = Submodule(
                name=sub_sub_name,
                path=os.path.join(submodule.path, sub_sub_path),
                indexed_hash=sub_hash.get_val(),
                checked_out_hash='',
                indexed_descr='',
                checked_out_descr='',
                initialized=False,
                derived=True,
                merge_conflicts=False)
            self.insert_new_sub(submodule, new_sub)

    def do_derive_repo_children(self, submodule):
        # Get rid of any derived subs before re-deriving.
        submodule.subs = []

        if not self.sub_exists_at_top_level(submodule):
            return

        # jump into top-level sub and:
        top_sub = self._top_subs[submodule.name]
        path = os.path.join(self._last_path, top_sub.path)
        self._console.write('Entering directory: ' + path)
        with DoInExistingDir(path) as ctx:
            if ctx:
                self.create_derived_repo_children(submodule)
            else:
                self._console.write(
                    'Could not switch to directory %s '
                    'for submodule %s\n' % (path, submodule.name))
                return

    def do_derive_uninitialized_repos(self, submodule):
        if not submodule.initialized:
            self.do_derive_repo_children(submodule)

        self.do_derive_uninitialized_child_repos(submodule)

    def do_derive_uninitialized_child_repos(self, submodule):
        for sub in submodule.subs:
            self.do_derive_uninitialized_repos(sub)

    def derive_uninitialized_repos(self):
        self.do_derive_uninitialized_child_repos(self._root_sub)

    def do_calc_ahead_behind_adjacent(self, submodule_hash, top_sub_hash):
        if not get_commit_exists(submodule_hash):
            return Result(CommitDirection.MISSING)

        result = get_commit_is_ancestor(submodule_hash, top_sub_hash)
        if result:
            if result.get_val():
                return Result(CommitDirection.BEHIND)
        else:
            return result

        result = get_commit_is_ancestor(top_sub_hash, submodule_hash)
        if result:
            if result.get_val():
                return Result(CommitDirection.AHEAD)
        else:
            return result

        return Result(CommitDirection.ADJACENT)

    def calc_ahead_behind_adjacent_in_dir(self, submodule, top_sub):
        if submodule.relation_to_top_indexed == CommitDirection.NONE:
            result = self.do_calc_ahead_behind_adjacent(
                submodule.indexed_hash, top_sub.indexed_hash)
            if result:
                submodule.relation_to_top_indexed = result.get_val()
            else:
                self._console.write(
                    'Error determining commit ancestry:\n'
                    '  %s' % result.get_err())

        if submodule.relation_to_top_checked_out == CommitDirection.NONE:
            result = self.do_calc_ahead_behind_adjacent(
                submodule.indexed_hash, top_sub.checked_out_hash)
            if result:
                submodule.relation_to_top_checked_out = result.get_val()
            else:
                self._console.write(
                    'Error determining commit ancestry:\n'
                    '  %s' % result.get_err())

    def calc_ahead_behind_adjacent(self, submodule, top_sub):
        path = os.path.join(self._last_path, top_sub.path)
        with DoInExistingDir(path) as ctx:
            if ctx:
                self.calc_ahead_behind_adjacent_in_dir(submodule, top_sub)
            else:
                self._console.write(
                    'Could not switch to directory %s '
                    'for submodule %s\n' % (path, top_sub.name))
                return

    def calc_stats(self, submodule):
        submodule.is_top_level = submodule in self._top_subs.values()
        submodule.missing_at_top = not self.sub_exists_at_top_level(submodule)

        submodule.relation_to_top_indexed = CommitDirection.NONE
        submodule.relation_to_top_checked_out = CommitDirection.NONE

        if (submodule == self._root_sub
            or submodule.is_top_level
            or submodule.missing_at_top):

            return

        top_sub = self._top_subs[submodule.name]

        if submodule.indexed_hash == top_sub.indexed_hash:
            submodule.relation_to_top_indexed = CommitDirection.MATCHES

        if submodule.indexed_hash == top_sub.checked_out_hash:
            submodule.relation_to_top_checked_out = CommitDirection.MATCHES

        self.calc_ahead_behind_adjacent(submodule, top_sub)

    def calc_stats_recursive(self, submodule):
        self.calc_stats(submodule)
        for sub in submodule.subs:
            self.calc_stats_recursive(sub)


def center_on(window, target):
    window.update_idletasks()
    height = window.winfo_height()
    width = window.winfo_width()
    x = int(target.winfo_x() + (target.winfo_width() / 2 - width / 2))
    y = int(target.winfo_y() + (target.winfo_height() / 2 - height / 2))

    window.geometry(f"{width}x{height}+{x}+{y}")


def set_up_wheel_scrolling(canvas):
    def on_mousewheel(event):
        delta = 1 if event.delta > 0 else -1
        canvas.yview_scroll(-delta, 'units')

    def bound_to_mousewheel(event):
        canvas.bind_all('<MouseWheel>', on_mousewheel)
        canvas.bind_all('<Button-4>', on_mousewheel)
        canvas.bind_all('<Button-5>', on_mousewheel)

    def unbound_to_mousewheel(event):
        canvas.unbind_all('<MouseWheel>')
        canvas.unbind_all('<Button-4>')
        canvas.unbind_all('<Button-5>')

    canvas.bind('<Enter>', bound_to_mousewheel)
    canvas.bind('<Leave>', unbound_to_mousewheel)


class ScrollableFrame(tk.Frame):
    def __init__(self, container, *args, **kwargs):
        super().__init__(container, *args, **kwargs)
        canvas = tk.Canvas(self)
        scrollbar = tk.Scrollbar(self, orient='vertical', command=canvas.yview)
        self.scrollframe = tk.Frame(canvas)

        self.scrollframe.bind(
            '<Configure>',
            lambda e: canvas.configure(
                scrollregion=canvas.bbox('all')
            )
        )

        canvas.create_window((0, 0), window=self.scrollframe, anchor=tk.NW)

        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        set_up_wheel_scrolling(canvas)

class InfoBox:

    root = None

    def __init__(self, submodule):
        my_class = self.__class__

        if not hasattr(my_class, 'txt_font'):
            default_font = tk.font.nametofont('TkDefaultFont')
            my_class.txt_font = tk.font.Font(
                family=default_font['family'], size=10)
            my_class.txt_font_bold = my_class.txt_font.copy()
            my_class.txt_font_bold['weight'] = 'bold'
            my_class.txt_font_italic = my_class.txt_font.copy()
            my_class.txt_font_italic['slant'] = 'italic'

        dlg = tk.Toplevel(InfoBox.root)
        dlg.wm_title('Details')
        dlg['bd'] = 5

        def make_text(parent):
            text = tk.Text(parent, height=1, font=my_class.txt_font)
            text.tag_configure('bold', font=my_class.txt_font_bold)
            text.tag_configure('italic', font=my_class.txt_font_italic)
            text['bg'] = text.master['bg']
            text['relief'] = tk.FLAT
            return text

        o_len_pix = my_class.txt_font.measure('0')

        def get_fit_text_width(txt_widget):
            text = txt_widget.get(1.0, tk.END)
            lines = text.split('\n')
            line_lens_pix = [my_class.txt_font.measure(line) for line in lines]
            txt_len_pix = max(line_lens_pix)
            txt_len_chars = math.ceil(txt_len_pix / o_len_pix)
            return txt_len_chars

        row = 0

        lbl = tk.Label(dlg,
            text='Submodule %s' % submodule.name,
            font=my_class.txt_font_bold)
        lbl.grid(row=row, column=0, sticky=tk.W, columnspan=2, padx=2, pady=2)
        row += 1

        lbl = tk.Label(dlg, text='Path:')
        lbl.grid(row=1, column=0, sticky=tk.W)
        text = make_text(dlg)
        text.insert('end', submodule.path)
        text['state'] = tk.DISABLED
        text['width'] = get_fit_text_width(text)
        text.grid(row=row, column=1, sticky=tk.W, padx=(5, 0))
        row += 1

        lbl = tk.Label(dlg, text='Indexed commit:')
        lbl.grid(row=2, column=0, sticky=tk.W)
        text = make_text(dlg)
        indexed_str = submodule.indexed_hash[:8]
        if submodule.indexed_descr:
            descr = remove_commit_descr_prefix(submodule.indexed_descr)
            indexed_str += ' (%s)' % descr
        text.insert('end', indexed_str)
        text['state'] = tk.DISABLED
        text['width'] = get_fit_text_width(text)
        text.grid(row=row, column=1, sticky=tk.W, padx=(5, 0))
        row += 1

        lbl = tk.Label(dlg, text='Checked out commit:')
        lbl.grid(row=3, column=0, sticky=tk.W)
        text = make_text(dlg)
        if submodule.initialized:
            checked_out_str = submodule.checked_out_hash[:8]
            if submodule.checked_out_descr:
                descr = remove_commit_descr_prefix(submodule.checked_out_descr)
                checked_out_str += ' (%s)' % descr
            text.insert('end', checked_out_str)
        else:
            descr = 'Submodule is '
            descr += 'derived' if submodule.derived else 'uninitialized'
            text.insert('end', '%s' % descr, 'italic')
        text['state'] = tk.DISABLED
        text['width'] = get_fit_text_width(text)
        text.grid(row=row, column=1, sticky=tk.W, padx=(5, 0))
        row += 1

        if submodule.is_top_level and not submodule.initialized:
            text = make_text(dlg)
            text['height'] = 2
            text['bg'] = 'pink'
            text.insert('end', 'Note: ', 'bold')
            note = (
                'This submodule is uninitialized at the top level,\n'
                'which is probably incorrect.')
            text.insert('end', note)
            text['width'] = get_fit_text_width(text) + 1 # +1 for bolded text
            text.grid(row=row, column=0, columnspan=2, sticky=tk.W, pady=(5, 0))
            row += 1

        if not submodule.is_top_level and submodule.missing_at_top:
            text = make_text(dlg)
            text['height'] = 2
            text['bg'] = 'yellow3'
            text.insert('end', 'Note: ', 'bold')
            note = (
                'This submodule does not exist at the top level of the\n'
                'project, which is notable but may not be an error.')
            text.insert('end', note)
            text['width'] = get_fit_text_width(text) + 1 # +1 for bolded text
            text.grid(row=row, column=0, columnspan=2, sticky=tk.W, pady=(5, 0))
            row += 1

        dlg.update()
        dlg_width = dlg.winfo_width()

        dlg.columnconfigure(1, weight=1)
        AHEAD_OF_TXT = 'AHEAD OF'
        BEHIND_TXT = 'BEHIND'
        ADJACENT_TO_TXT = 'ADJACENT TO'
        MISSING_TXT = 'MISSING'
        INDEXED_TXT = 'INDEXED'
        CHECKED_OUT_TXT = 'CHECKED_OUT'
        def make_relation_note(relation_txt, commit_type_txt):
            nonlocal row
            dlg.rowconfigure(row, weight=1)
            text = make_text(dlg)
            text['wrap'] = tk.WORD
            text['bg'] = 'yellow3'
            text.insert('end', 'Note: ', 'bold')
            note = (
                'The commit expected by this submodule\'s parent is %s '
                'the commit currently %s by the copy of this submodule at the '
                'top level, which is notable but may not be an error.'
                % (relation_txt, commit_type_txt))
            if relation_txt == ADJACENT_TO_TXT:
                note += (
                    ' (Adjacency occurs when the commits being compared are '
                    'on divergent branches.)')
                text['height'] += 1
            if relation_txt == MISSING_TXT:
                note = (
                    'The commit expected by this submodule\'s parent is %s '
                    'from the copy of this submodule at the '
                    'top level, which is notable but may not be an error.'
                    % (relation_txt))
            text.insert('end', note)

            # Texts are 80 wide by default, but we only want it to use the width
            # of the dialog so far.
            text['width'] = math.ceil(dlg_width / o_len_pix)

            text.grid(
                row=row, column=0, columnspan=2, sticky='nsew', pady=(5, 0))
            row += 1

            # Now, the text would have word wrapped, and we need the number of
            # lines it would prefer to display so we can make sure the text
            # widget is larget enough to display everything.
            dlg.update()
            num_lines = text.count('1.0', 'end', 'displaylines')
            text['height'] = num_lines

        can_relate_to_top = (
            not submodule.is_top_level
            and not submodule.missing_at_top)

        if can_relate_to_top:
            idx_relation = submodule.relation_to_top_indexed
            if idx_relation == CommitDirection.AHEAD:
                make_relation_note(AHEAD_OF_TXT, INDEXED_TXT)
            elif idx_relation == CommitDirection.BEHIND:
                make_relation_note(BEHIND_TXT, INDEXED_TXT)
            elif idx_relation == CommitDirection.ADJACENT:
                make_relation_note(ADJACENT_TO_TXT, INDEXED_TXT)
            elif idx_relation == CommitDirection.MISSING:
                make_relation_note(MISSING_TXT, '')

            checked_out_relation = submodule.relation_to_top_checked_out
            if checked_out_relation == CommitDirection.AHEAD:
                make_relation_note(AHEAD_OF_TXT, CHECKED_OUT_TXT)
            elif checked_out_relation == CommitDirection.BEHIND:
                make_relation_note(BEHIND_TXT, CHECKED_OUT_TXT)
            elif checked_out_relation == CommitDirection.ADJACENT:
                make_relation_note(ADJACENT_TO_TXT, CHECKED_OUT_TXT)
            elif checked_out_relation == CommitDirection.MISSING:
                make_relation_note(MISSING_TXT, '')

        center_on(dlg, InfoBox.root)

        # make the dialog modal
        dlg.focus_set()
        dlg.grab_set()
        dlg.wait_window()

        self.dlg = dlg


class SyncBox:

    root = None

    def __init__(self, submodule, flatter):
        my_class = self.__class__

        dlg = tk.Toplevel(SyncBox.root)
        dlg.wm_title('Sync Top')
        dlg['bd'] = 2

        dlg.columnconfigure(0, weight=1)

        row = 0

        tk.Label(dlg, text='Choose actions:').grid(
            row=row, column=0, sticky=tk.W)
        row += 1

        actions_frame = ScrollableFrame(dlg, relief=tk.SUNKEN, bd=2)

        # Temp sample action frame content.
        for i in range(20):
            lbl = tk.Label(actions_frame.scrollframe, text='action %d' % i)
            lbl.pack(anchor=tk.NW)

        actions_frame.grid(row=row, column=0, sticky=tk.NSEW)
        dlg.rowconfigure(row, weight=1)
        row += 1

        tk.Label(dlg, text='Commands:', anchor=tk.W).grid(
            row=row, column=0, sticky=tk.EW, pady=(5, 0))
        row += 1

        cmds_frame = tk.Frame(dlg)

        cmds_scrollbar = tk.Scrollbar(cmds_frame)
        cmds_txt = tk.Text(cmds_frame, bg='light grey')
        cmds_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        cmds_txt.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        cmds_scrollbar.config(command=cmds_txt.yview)
        cmds_txt.config(yscrollcommand=cmds_scrollbar.set)
        self.cmds_txt = cmds_txt

        cmds_frame.grid(row=row, column=0, sticky=tk.NSEW)
        dlg.rowconfigure(row, weight=1)
        row += 1

        # Temp sample commands
        for i in range(40):
            cmds_txt.insert(tk.END, '> line %d\n' % i)

        center_on(dlg, SyncBox.root)

        # make the dialog modal
        dlg.focus_set()
        dlg.grab_set()
        dlg.wait_window()

        self.dlg = dlg


class SubmodFrame(tk.Frame):
    def __init__(self, submodule, flatter, *args, **kwargs):
        my_class = self.__class__

        super(SubmodFrame, self).__init__(*args, **kwargs)
        self.submodule = submodule
        self.flatter = flatter

        if not hasattr(my_class, 'txt_font'):
            default_font = tk.font.nametofont('TkDefaultFont')
            my_class.txt_font = tk.font.Font(
                family=default_font['family'], size=10)
            my_class.txt_font_bold = my_class.txt_font.copy()
            my_class.txt_font_bold['weight'] = 'bold'
            my_class.txt_font_italic = my_class.txt_font.copy()
            my_class.txt_font_italic['slant'] = 'italic'

        parent = args[0]
        self['bg'] = parent['bg']

        outer_frame = tk.Frame(self,
            highlightthickness=0)
        outer_frame.pack(anchor=tk.NW)

        border_canvas = tk.Canvas(outer_frame,
            highlightthickness=0,
            bg=parent['bg'])
        border_canvas.bind(
            '<Configure>',
            lambda e: self.on_border_canvas_cfg(e))
        border_canvas.pack(side=tk.LEFT, ipadx=4, ipady=4)
        self.border_canvas = border_canvas

        data_frame = tk.Frame(border_canvas)

        if submodule.missing_at_top:
            data_frame['bg'] = 'yellow3'
        elif not submodule.initialized:
            if submodule.is_top_level:
                data_frame['bg'] = 'pink'
            else:
                data_frame['bg'] = 'light gray'
        else:
            data_frame['bg'] = 'white'

        def make_text():
            text = tk.Text(data_frame, height=1, font=my_class.txt_font)
            text.tag_configure('bold', font=my_class.txt_font_bold)
            text.tag_configure('italic', font=my_class.txt_font_italic)
            text['bg'] = text.master['bg']
            text['relief'] = tk.FLAT
            return text

        o_len_pix = my_class.txt_font.measure('0')

        def get_fit_text_width(txt_widget):
            text = txt_widget.get(1.0, tk.END)
            txt_len_pix = my_class.txt_font.measure(text)
            txt_len_chars = math.ceil(txt_len_pix / o_len_pix)
            return txt_len_chars

        text = make_text()
        text.insert('end', submodule.name, 'bold')
        text['state'] = tk.DISABLED
        text['width'] = get_fit_text_width(text)
        text.pack(anchor=tk.W)

        text = make_text()

        indexed_str = submodule.indexed_hash[:8]
        if submodule.indexed_descr:
            descr = remove_commit_descr_prefix(submodule.indexed_descr)
            indexed_str += ' (%s)' % descr
        text.insert('end', 'Idx commit: %s' % indexed_str)

        if submodule.initialized:
            checked_out_str = submodule.checked_out_hash[:8]
            if submodule.checked_out_descr:
                descr = remove_commit_descr_prefix(submodule.checked_out_descr)
                checked_out_str += ' (%s)' % descr
            text.insert('end', ', Checked out: %s' % checked_out_str)
        else:
            descr = 'derived' if submodule.derived else 'uninitialized'
            text.insert('end', ', ')
            text.insert('end', '%s' % descr, 'italic')

        text['state'] = tk.DISABLED
        text['width'] = get_fit_text_width(text)
        text.pack(anchor=tk.W)

        self.create_submodule_buttons(outer_frame, submodule)
        self.create_relation_labels(outer_frame, submodule)

        data_frame.pack(anchor=tk.CENTER, fill=tk.NONE, expand=True)

        left_spacer_frame = tk.Frame(self, bg=self['bg'], width=25)
        left_spacer_frame.pack(side=tk.LEFT)

        subs_frame = tk.Frame(self, bg=self['bg'])
        subs_frame.pack(anchor='nw')

        for child in submodule.subs:
            frm = SubmodFrame(child, self.flatter, subs_frame)

        self.pack(anchor=tk.NW, pady=(20, 0))

    def create_submodule_buttons(self, parent, submodule):
        info_btn = tk.Button(parent,
            text='Details',
            padx=5, pady=0,
            command=lambda: self.show_submodule_info(submodule))
        info_btn.pack(side=tk.LEFT, fill=tk.BOTH)

        info_btn = tk.Button(parent,
            text='Sync Top',
            padx=0, pady=0,
            command=lambda: self.sync_to_top(submodule.name))
        info_btn.pack(side=tk.LEFT, fill=tk.BOTH)

    def create_relation_labels(self, parent, submodule):
        frm = tk.Frame(parent)

        def make_relation_lbl(relation, commit_type_txt):
            if (relation == CommitDirection.NONE
                or relation == CommitDirection.MATCHES):
                return None

            lbl = tk.Label(frm,
                anchor=tk.E,
                borderwidth=1,
                relief='solid',
                pady=4)
            lbl['bg'] = 'yellow3'
            if relation == CommitDirection.AHEAD:
                lbl['text'] = 'AHEAD of %s commit' % commit_type_txt
            elif relation == CommitDirection.BEHIND:
                lbl['text'] = 'BEHIND %s commit' % commit_type_txt
            elif relation == CommitDirection.ADJACENT:
                lbl['text'] = 'ADJACENT to %s commit' % commit_type_txt
            elif relation == CommitDirection.MISSING:
                lbl['text'] = 'Repo commit MISSING'
            else:
                lbl['text'] = ''

            return lbl

        idx_lbl = make_relation_lbl(submodule.relation_to_top_indexed, 'IDX')
        co_lbl = make_relation_lbl(submodule.relation_to_top_checked_out, 'CO')

        if idx_lbl:
            idx_lbl.grid(row=0, column=0, sticky='nsew')
        if co_lbl:
            co_lbl.grid(row=1, column=0, sticky='nsew')

        if idx_lbl or co_lbl:
            frm.pack(side=tk.LEFT)

    def on_border_canvas_cfg(self, event):
        left = 2
        top = 2
        right = event.widget.winfo_width() - 2
        bottom = event.widget.winfo_height() - 2

        if self.submodule.initialized:
            dash = ''
            outline = 'black'
        else:
            dash = (10, 2)
            outline = 'dim grey'

        self.border_canvas.delete('border_line')
        self.border_canvas.create_rectangle(
            left, top, right, bottom,
            width=2, outline=outline, dash=dash, tag='border_line')

    def show_submodule_info(self, submodule):
        InfoBox(submodule)

    def sync_to_top(self, submodule):
        SyncBox(submodule, self.flatter)


class GraphFrame(tk.Frame):
    def __init__(self, parent=None):
        tk.Frame.__init__(self, parent)

        self.flatter = None
        self.submod_frames = []

        self.init_canvas()

    def init_canvas(self):
        canvas = tk.Canvas(self, bg='dark grey')
        canvas['highlightthickness'] = 0

        main_frm = tk.Frame(canvas, bg=canvas['bg'], padx=20)
        main_frm.bind(
            '<Configure>',
            lambda e: canvas.configure(
                scrollregion=canvas.bbox("all")
            )
        )
        canvas.create_window((0, 0), window=main_frm, anchor=tk.NW)

        vertical = tk.Scrollbar(self)
        vertical.config(command=canvas.yview)             # xlink sbar and canv
        canvas.config(yscrollcommand=vertical.set)        # move one moves other
        vertical.pack(side=tk.RIGHT, fill=tk.Y)           # pack first=clip last

        horizontal = tk.Scrollbar(self, orient=tk.HORIZONTAL)
        horizontal.config(command=canvas.xview)           # xlink sbar and canv
        canvas.config(xscrollcommand=horizontal.set)      # move one moves other
        horizontal.pack(side=tk.BOTTOM, fill=tk.X)        # pack first=clip last

        canvas.pack(side=tk.LEFT, expand=tk.YES, fill=tk.BOTH)

        set_up_wheel_scrolling(canvas)

        self.canvas = canvas
        self.main_frm = main_frm

    def update_ui(self, flatter):
        for submod_frame in self.submod_frames:
            submod_frame.destroy()
        self.submod_frames = []

        self.flatter = flatter
        root_sub = flatter.get_root_sub()

        for sub in root_sub.subs:
            frm = SubmodFrame(sub, self.flatter, self.main_frm)
            self.submod_frames.append(frm)


class FlatterWinConsole:
    def __init__(self, win):
        self.win = win

    def write(self, text):
        self.win.add_to_console(text)


class FlatterWin:
    def __init__(self, root=None):
        if root is None:
            root = tk.Tk()
            root['bg'] = 'light grey'

        InfoBox.root = root
        SyncBox.root = root

        bg_color = root['bg']
        self.root = root
        self.flatter = Flatter(FlatterWinConsole(self))

        root.wm_title('Flatter!')

        style = ttk.Style()
        style.configure('TPanedwindow', background=bg_color)

        w = root.winfo_screenwidth() / 2
        h = root.winfo_screenheight() / 2
        root.geometry('%dx%d' % (w, h))

        root.protocol('WM_DELETE_WINDOW', self.on_destroy)

        self.init_menu()

        button_frame = tk.Frame(root, bg=bg_color)
        button_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)

        fetch_top_subs_btn = tk.Button(button_frame,
            text='Fetch Immediate\nSubmodules',
            command=self.fetch_immediate_submodules)
        fetch_top_subs_btn.pack(side=tk.TOP, fill=tk.X)

        pane1 = ttk.PanedWindow(orient=tk.VERTICAL)
        pane1.pack(fill=tk.BOTH, expand=True)

        self.graph_frame = GraphFrame(pane1)

        console_frame = tk.Frame(pane1)

        self.console_scrollbar = tk.Scrollbar(console_frame)
        self.console = tk.Text(console_frame, bg=bg_color)
        self.console_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.console.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.console_scrollbar.config(command=self.console.yview)
        self.console.config(yscrollcommand=self.console_scrollbar.set)

        pane1.update()
        pane_height = pane1.winfo_height()
        top_height = max(pane_height - 100, 100)
        pane1.add(self.graph_frame, weight=1)
        pane1.add(console_frame)
        pane1.update()
        pane1.sashpos(0, top_height)

        root.after(50, lambda: self.open_dir('D:/code/flatter/test_repos/blee/app1')) # jbltemp

        root.mainloop()

    def on_destroy(self):
        self.root.destroy()
        sys.exit()

    def init_menu(self):
        menu_bar = tk.Menu(self.root)
        file_menu = tk.Menu(menu_bar, tearoff=0)
        file_menu.add_command(label='Open Repo', command=self.ask_open_dir)
        open_recents_menu = tk.Menu(file_menu, tearoff=0)
        file_menu.add_cascade(label='Open Recent', menu=open_recents_menu)
        file_menu.add_command(
            label='Refresh', command=self.refresh_repo, state='disabled')
        file_menu.add_separator()
        file_menu.add_command(label='Exit', command=self.on_destroy)

        menu_bar.add_cascade(label='File', menu=file_menu)

        self.root.config(menu=menu_bar)
        self.file_menu = file_menu
        self.open_recents_menu = open_recents_menu

        self.update_open_recent_menu()

    def update_open_recent_menu(self):
        self.open_recents_menu.delete(0, 'end')

        recents = self.flatter.get_recent_paths()
        state = 'normal' if recents else 'disabled'
        self.file_menu.entryconfig('Open Recent', state=state)

        if not recents:
            return

        # generator fn to correcty capture value of "recent" in closure
        def make_cmd():
            recent2 = recent
            return lambda: self.open_dir(recent2, from_recent=True)

        for recent in recents:
            self.open_recents_menu.add_command(
                label=recent,
                command=make_cmd())

    def ask_open_dir(self):
        path = tk.filedialog.askdirectory(
            initialdir=self.flatter.get_last_path())
        if path:
            self.open_dir(path)

    def do_long_job(self, work_fn):
        # Calling root.update() after setting the cursor is supposed to allow
        # the new cursor to take effect, but it doesn't so I decided to use
        # root.after(), which works, but the timeout has to be set high enough.
        # 1 ms did not work; 10 ms worked rarely; 50 ms seems to work every
        # time.
        self.root.config(cursor='wait')
        def inner_work_fn():
            work_fn()
            self.root.config(cursor='')
        self.root.after(50, inner_work_fn)

    def refresh_repo(self):
        def do_work():
            self.open_dir(self.flatter.get_last_path())
        self.do_long_job(do_work)

    def open_dir(self, path, from_recent=False):
        if not path:
            return

        result = self.flatter.open_dir(path)
        if not result:
            self.add_to_console(
                '====== ERROR ======\n' +
                result.get_err() + '\n' +
                '  ==== END ERROR ====')

            title = 'Error'
            err_txt = \
                'Couldn\'t open repo.\n' \
                '(See console for additional information.)'
            if from_recent:
                err_txt += '\n\nRemove from recent repos?'
                remove_recent = tk.messagebox.askquestion(
                    title, err_txt,
                    icon=tk.messagebox.ERROR)
                if remove_recent == tk.messagebox.YES:
                    self.flatter.remove_recent(path)
            else:
                tk.messagebox.showerror(title, err_txt)

        self.update_open_recent_menu()
        state = 'normal' if self.flatter.get_is_open() else 'disabled'
        self.file_menu.entryconfig('Refresh', state=state)

        if result:
            self.graph_frame.update_ui(self.flatter)

    def clear_console(self):
        self.console['state'] = tk.NORMAL
        self.console.delete(1.0, tk.END)
        self.console['state'] = tk.DISABLED

    def add_to_console(self, text):
        self.console['state'] = tk.NORMAL
        do_scroll = self.console_scrollbar.get()[1] == 1
        self.console.insert(tk.END, '> %s\n' % text)
        if do_scroll:
            self.console.see(tk.END)
        self.console['state'] = tk.DISABLED

    def fetch_immediate_submodules(self):
        def do_work():
            self.flatter.fetch_immediate_submodules()
            self.open_dir(self.flatter.get_last_path())
        self.do_long_job(do_work)

if __name__ == '__main__':
    FlatterWin()
