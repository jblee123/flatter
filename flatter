#!/usr/bin/env python3

################################################################################
# The MIT License (MIT)

# Copyright (c) 2020 J. Brian Lee

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
################################################################################

try:
    import tkinter as tk
except ModuleNotFoundError:
    sys.exit('error: tkinter not found. You may need to "pip install tk".')

import collections
import configparser
import os
import subprocess
import sys

import tkinter.filedialog
import tkinter.messagebox


class Result:
    def __init__(self, val=None, err=None):
        self.val = val
        self.err = err

    def __bool__(self):
        return not bool(self.err)

    def error(err):
        return Result(None, err)


class DoInExistingDir(object):
    def __init__(self, path):
        self.old_dir = os.getcwd()
        self.new_dir = path

    def __enter__(self):
        try:
            os.chdir(self.new_dir)
            return self
        except:
            return None

    def __exit__(self, type, value, traceback):
        os.chdir(self.old_dir)
        return isinstance(value, OSError)

def exec_proc(cmd, capture_output=True):
    sys.stdout.flush()
    sys.stderr.flush()

    shell = type(cmd) == str

    if capture_output:
        p = subprocess.Popen(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        out, err = p.communicate()
        out = out.decode('utf-8').strip()
        err = err.decode('utf-8').strip()
        return p.returncode, out, err
    else:
        return subprocess.call(cmd, shell=shell)


def get_lines(text):
    lines = text.split('\n') if text else []
    lines = [line.strip() for line in lines]
    return lines


def get_home_dir():
    # posix
    if 'HOME' in os.environ:
        return os.environ['HOME']
    # windows
    elif 'HOMEPATH' in os.environ:
        drive = os.environ['HOMEDRIVE'] if 'HOMEDRIVE' in os.environ else ''
        path = os.environ['HOMEPATH']
        return os.path.join(drive, path)
    # ???
    else:
        return os.path.abspath('.')


def get_git_hash(ref):
    (ret, out, err) = exec_proc(['git', 'rev-parse', ref])
    return out.strip() if ret == 0 else None


class Flatter:
    def __init__(self):
        self.home_dir = get_home_dir()
        self.last_path = self.home_dir
        self.recent_paths = []
        self.read_config()

    def get_last_path(self):
        return self.last_path

    def set_last_path(self, path):
        if not path:
            return

        self.last_path = path
        if path in self.recent_paths:
            self.recent_paths.remove(path)
        self.recent_paths.insert(0, path)
        self.recent_paths = self.recent_paths[:20]

    def get_recent_paths(self):
        return self.recent_paths[:]

    def remove_recent(self, path):
        if path in self.recent_paths:
            self.recent_paths.remove(path)
            self.write_config()

    def read_config(self):
        if not self.home_dir:
            return

        cfg_file_name = os.path.join(self.home_dir, '.flatter')
        config = configparser.ConfigParser()
        config.read(cfg_file_name)

        if config.has_section('paths'):
            self.last_path = config.get(
                'paths', 'last_path', fallback=self.last_path)

            recents = [item for item in config.items('paths')
                if item[0].startswith('recent_path_')]
            recents.sort(key=lambda pair : pair[0])
            self.recent_paths = [item[1] for item in recents]

    def write_config(self):
        if not self.home_dir:
            return

        paths = collections.OrderedDict()
        if self.last_path:
            paths['last_path'] = self.last_path

        idx = 0
        for recent_path in self.recent_paths:
            key = 'recent_path_%02d' % idx
            paths[key] = recent_path
            idx += 1

        cfg = collections.OrderedDict()
        cfg['paths'] = paths

        config = configparser.ConfigParser()
        config.read_dict(cfg)

        cfg_file_name = os.path.join(self.home_dir, '.flatter')
        with open(cfg_file_name, 'w') as configfile:
            config.write(configfile)

    def do_open_dir(self, path):
        if not path or not type(path) is str:
            return Result.error('bad path: "%s"' % str(path))

        (ret, out, err) = exec_proc('git status')
        if ret != 0:
            return Result.error(err)

        lines = get_lines(out)
        if not lines:
            err_txt = 'git status didn\'t return anything in path: %s' % path
            return Result.error(err_txt)

        detatched_marker = 'HEAD detached at '
        branch_marker = 'On branch '
        if lines[0].startswith(detatched_marker):
            branch = lines[0]
            commit = lines[0][len(detatched_marker):]
        elif lines[0].startswith(branch_marker):
            branch = lines[0][len(branch_marker):]
            commit = get_git_hash('HEAD')
        else:
            err_txt = (
                'bad git output:\n' +
                '  out: %s\n' +
                '  err: %s\n') % out, err
            return Result.error(err_txt)

        print('successfully opened path:', path)
        print('  branch:', branch)
        print('  commit:', commit)

        self.set_last_path(path)
        self.write_config()
        return Result()

    def open_dir(self, path):
        with DoInExistingDir(path) as ctx:
            if ctx:
                return self.do_open_dir(path)
            else:
                return Result.error('missing repo: %s' % path)


class FlatterFrame(tk.Frame):
    def __init__(self, parent=None):
        tk.Frame.__init__(self, parent)

        self.pack(expand=tk.YES, fill=tk.BOTH)            # make me expandable

        self.init_canvas()

    def init_canvas(self):
        canvas = tk.Canvas(self, bg='dark grey')
        # canvas.config(scrollregion=(0, 0, 500, 500))      # canvas size corners
        canvas.config(highlightthickness=0)               # no pixels to border

        vertical = tk.Scrollbar(self)
        vertical.config(command=canvas.yview)             # xlink sbar and canv
        canvas.config(yscrollcommand=vertical.set)        # move one moves other
        vertical.pack(side=tk.RIGHT, fill=tk.Y)           # pack first=clip last

        horizontal = tk.Scrollbar(self, orient=tk.HORIZONTAL)
        horizontal.config(command=canvas.xview)           # xlink sbar and canv
        canvas.config(xscrollcommand=horizontal.set)      # move one moves other
        horizontal.pack(side=tk.BOTTOM, fill=tk.X)        # pack first=clip last

        canvas.pack(side=tk.LEFT, expand=tk.YES, fill=tk.BOTH) # canv clipped first

        self.canvas = canvas


class FlatterWin:
    def __init__(self, root=None):
        if root is None:
            root = tk.Tk()
        self.root = root
        self.flatter = Flatter()

        root.wm_title('Flatter!')

        w = root.winfo_screenwidth() / 2
        h = root.winfo_screenheight() / 2
        root.geometry('%dx%d' % (w, h))

        root.protocol('WM_DELETE_WINDOW', self.on_destroy)

        self.init_menu()

        FlatterFrame(root)

        root.mainloop()

    def on_destroy(self):
        self.root.destroy()
        sys.exit()

    def init_menu(self):
        menu_bar = tk.Menu(self.root)
        file_menu = tk.Menu(menu_bar, tearoff=0)
        file_menu.add_command(label='Open Repo', command=self.ask_open_dir)
        open_recents_menu = tk.Menu(file_menu, tearoff=0)
        file_menu.add_cascade(label='Open Recent', menu=open_recents_menu)
        file_menu.add_command(
            label='Refresh', command=self.refresh_repo, state='disabled')
        file_menu.add_separator()
        file_menu.add_command(label='Exit', command=self.on_destroy)

        menu_bar.add_cascade(label='File', menu=file_menu)

        self.root.config(menu=menu_bar)
        self.file_menu = file_menu
        self.open_recents_menu = open_recents_menu

        self.update_open_recent_menu()

    def update_open_recent_menu(self):
        self.open_recents_menu.delete(0, 'end')

        recents = self.flatter.get_recent_paths()
        state = 'normal' if recents else 'disabled'
        self.file_menu.entryconfig('Open Recent', state=state)

        if not recents:
            return

        # generator fn to correcty capture value of "recent" in closure
        def make_cmd():
            recent2 = recent
            return lambda: self.open_dir(recent2, from_recent=True)

        for recent in recents:
            self.open_recents_menu.add_command(
                label=recent,
                command=make_cmd())

    def ask_open_dir(self):
        path = tk.filedialog.askdirectory(
            initialdir=self.flatter.get_last_path())
        if path:
            self.open_dir(path)

    def refresh_repo(self):
        self.open_dir(self.flatter.get_last_path())

    def open_dir(self, path, from_recent=False):
        if not path:
            return

        result = self.flatter.open_dir(path)
        if not result:
            title = 'Couldn\'t open repo'
            if from_recent:
                err_txt = (result.err + '\n\n' +
                    'Remove from recent repos?')
                remove_recent = tk.messagebox.askquestion(
                    title, result.err,
                    icon=tk.messagebox.ERROR)
                if remove_recent == tk.messagebox.YES:
                    self.flatter.remove_recent(path)
            else:
                tk.messagebox.showerror(title, result.err)

        self.update_open_recent_menu()
        state = 'normal' if result else 'disabled'
        self.file_menu.entryconfig('Refresh', state=state)


if __name__ == '__main__':
    FlatterWin()
