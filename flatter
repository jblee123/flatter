#!/usr/bin/env python3

################################################################################
# The MIT License (MIT)

# Copyright (c) 2020 J. Brian Lee

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
################################################################################

try:
    import tkinter as tk
except ModuleNotFoundError:
    sys.exit('error: tkinter not found. You may need to "pip install tk".')

import collections
import configparser
import os
import pprint
import re
import subprocess
import sys

import tkinter.filedialog
import tkinter.messagebox


class Result:
    def __init__(self, val=None, err=None):
        self._val = val
        self._err = err

    def __bool__(self):
        return not bool(self._err)

    def get_val(self):
        if self._err:
            raise RuntimeError('Getting Result value from error Result')
        return self._val

    def get_err(self):
        return self._err

    def error(err):
        return Result(None, err)


class DoInExistingDir(object):
    def __init__(self, path):
        self._old_dir = os.getcwd()
        self._new_dir = path

    def __enter__(self):
        try:
            os.chdir(self._new_dir)
            return self
        except:
            return None

    def __exit__(self, type, value, traceback):
        os.chdir(self._old_dir)
        return isinstance(value, OSError)

def exec_proc(cmd, capture_output=True):
    sys.stdout.flush()
    sys.stderr.flush()

    shell = type(cmd) == str

    if capture_output:
        p = subprocess.Popen(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        out, err = p.communicate()
        out = out.decode('utf-8').strip()
        err = err.decode('utf-8').strip()
        return p.returncode, out, err
    else:
        return subprocess.call(cmd, shell=shell)


def get_lines(text):
    lines = text.split('\n') if text else []
    # lines = [line.strip() for line in lines]
    return lines


def get_home_dir():
    # posix
    if 'HOME' in os.environ:
        return os.environ['HOME']
    # windows
    elif 'HOMEPATH' in os.environ:
        drive = os.environ['HOMEDRIVE'] if 'HOMEDRIVE' in os.environ else ''
        path = os.environ['HOMEPATH']
        return os.path.join(drive, path)
    # ???
    else:
        return os.path.abspath('.')


def make_git_err_msg(cmd, out, err):
    if type(cmd) == list:
        cmd = ' '.join(cmd)
    err_str = \
        'git cmd failed: \"' + cmd + '\"\n' \
        '  out: ' + out + '\n' \
        '  err: ' + err
    return Result.error(err_str)

def get_git_hash(ref):
    cmd = ['git', 'rev-parse', ref]
    (ret, out, err) = exec_proc(cmd)
    if ret == 0:
        return Result(out.strip())
    else:
        return make_git_err_msg(cmd, out, err)


def get_submodule_status(cached):
    cmd = 'git submodule status --recursive'
    if cached:
        cmd += ' --cached'
    (ret, out, err) = exec_proc(cmd)
    if ret == 0:
        return Result(get_lines(out.strip()))
    else:
        return make_git_err_msg(cmd, out, err)


class Submodule:
    def __init__(self,
        name, path,
        indexed_hash, checked_out_hash,
        indexed_descr, checked_out_descr,
        initialized, merge_conflicts):

        self.name = name
        self.path = path
        self.indexed_hash = indexed_hash
        self.checked_out_hash = checked_out_hash
        self.indexed_descr = indexed_descr
        self.checked_out_descr = checked_out_descr
        self.initialized = initialized
        self.merge_conflicts = merge_conflicts
        self.subs = []

    def add_sub(self, sub):
        self.subs.append(sub)


class Flatter:
    def __init__(self):
        self._is_open = False
        self._home_dir = get_home_dir()
        self._last_path = self._home_dir
        self._recent_paths = []
        self._root_sub = self.create_root_sub()
        self.read_config()

    def get_is_open(self):
        return self._is_open

    def create_root_sub(self):
        return Submodule(
            name='', path='',
            indexed_hash='', checked_out_hash='',
            indexed_descr='', checked_out_descr='',
            initialized=False, merge_conflicts=False)

    def get_last_path(self):
        return self._last_path

    def set_last_path(self, path):
        if not path:
            return

        self._last_path = path
        if path in self._recent_paths:
            self._recent_paths.remove(path)
        self._recent_paths.insert(0, path)
        self._recent_paths = self._recent_paths[:20]

    def get_recent_paths(self):
        return self._recent_paths[:]

    def remove_recent(self, path):
        if path in self._recent_paths:
            self._recent_paths.remove(path)
            self.write_config()

    def read_config(self):
        if not self._home_dir:
            return

        cfg_file_name = os.path.join(self._home_dir, '.flatter')
        config = configparser.ConfigParser()
        config.read(cfg_file_name)

        if config.has_section('paths'):
            self._last_path = config.get(
                'paths', 'last_path', fallback=self._last_path)

            recents = [item for item in config.items('paths')
                if item[0].startswith('recent_path_')]
            recents.sort(key=lambda pair : pair[0])
            self._recent_paths = [item[1] for item in recents]

    def write_config(self):
        if not self._home_dir:
            return

        paths = collections.OrderedDict()
        if self._last_path:
            paths['last_path'] = self._last_path

        idx = 0
        for recent_path in self._recent_paths:
            key = 'recent_path_%02d' % idx
            paths[key] = recent_path
            idx += 1

        cfg = collections.OrderedDict()
        cfg['paths'] = paths

        config = configparser.ConfigParser()
        config.read_dict(cfg)

        cfg_file_name = os.path.join(self._home_dir, '.flatter')
        with open(cfg_file_name, 'w') as configfile:
            config.write(configfile)

    def insert_new_sub(self, root_sub, new_sub):
        for sub in root_sub.subs:
            if new_sub.path.startswith(sub.path + '/'):
                self.insert_new_sub(sub, new_sub)
                return
        root_sub.add_sub(new_sub)

    def build_submodule_tree(self):
        result = get_submodule_status(cached=True)
        if not result:
            return result
        indexed_subs = result.get_val()

        result = get_submodule_status(cached=False)
        if not result:
            return result
        checked_out_subs = result.get_val()

        if len(indexed_subs) != len(checked_out_subs):
            return Result.error(
                'indexed and checked out submodule lists were not the ' \
                'same length')

        root_sub = self.create_root_sub()

        i = 0
        while i < len(indexed_subs):
            indexed_sub = indexed_subs[i]
            checked_out_sub = checked_out_subs[i]
            if not indexed_sub:
                return Result.error('indexed submodule line was empty')
            if not checked_out_sub:
                return Result.error('checked out submodule line was empty')
            if indexed_sub[0] != checked_out_sub[0]:
                return Result.error(
                    'submodule lines aren\' compatible; ' \
                    'first characters must match.\n' \
                    '    indexed: %s\n' \
                    'checked out: %s\n' % \
                    (indexed_sub, checked_out_sub))

            initialized = indexed_sub[0] != '-'
            merge_conflicts = indexed_sub[0] != 'U'

            indexed_sub = indexed_sub[1:].split(' ')
            checked_out_sub = checked_out_sub[1:].split(' ')

            if len(indexed_sub) < 2:
                return Result.error('indexed submodule line too short')
            if len(checked_out_sub) < 2:
                return Result.error('checked out submodule line too short')

            indexed_hash = indexed_sub[0]
            checked_out_hash = checked_out_sub[0]

            if indexed_sub[1] != checked_out_sub[1]:
                return Result.error(
                    'sub paths didn\'t match:\n' \
                    '  "%s" != "%s"' % (indexed_sub[1], checked_out_sub[1]))

            sub_path = indexed_sub[1]
            sub_name = os.path.basename(sub_path)

            indexed_descr = ''
            if len(indexed_sub) >= 3:
                indexed_descr = indexed_sub[2]
                indexed_descr = re.sub(r'^\(', '', indexed_descr)
                indexed_descr = re.sub(r'\)$', '', indexed_descr)

            checked_out_descr = ''
            if len(checked_out_sub) >= 3:
                checked_out_descr = checked_out_sub[2]
                checked_out_descr = re.sub(r'^\(', '', checked_out_descr)
                checked_out_descr = re.sub(r'\)$', '', checked_out_descr)

            new_sub = Submodule(
                name=sub_name,
                path=sub_path,
                indexed_hash=indexed_hash,
                checked_out_hash=checked_out_hash,
                indexed_descr=indexed_descr,
                checked_out_descr=checked_out_descr,
                initialized=initialized,
                merge_conflicts=merge_conflicts)
            self.insert_new_sub(root_sub, new_sub)

            i += 1

        _root_sub = root_sub;

        return Result()

    def do_open_dir(self, path):
        if not path or not type(path) is str:
            return Result.error('bad path: "%s"' % str(path))

        git_status_cmd = 'git status'
        (ret, out, err) = exec_proc(git_status_cmd)
        if ret != 0:
            return Result.error(err)

        lines = get_lines(out)
        if not lines:
            err_txt = 'git status didn\'t return anything in path: %s' % path
            return Result.error(err_txt)

        detatched_marker = 'HEAD detached at '
        branch_marker = 'On branch '
        if lines[0].startswith(detatched_marker):
            branch = lines[0]
            commit = lines[0][len(detatched_marker):]
        elif lines[0].startswith(branch_marker):
            branch = lines[0][len(branch_marker):]
            commit_result = get_git_hash('HEAD')
            if not commit_result:
                return commit_result
            commit = commit_result.get_val()
        else:
            err_txt = (
                'bad git output:\n' +
                '  out: %s\n' +
                '  err: %s\n') % out, err
            return make_git_err_msg(git_status_cmd, out, err)

        print('successfully opened path:', path)
        print('  branch:', branch)
        print('  commit:', commit)

        result = self.build_submodule_tree()
        if result:
            self._is_open = True
            self.set_last_path(path)
            self.write_config()

        return result

    def open_dir(self, path):
        with DoInExistingDir(path) as ctx:
            if ctx:
                return self.do_open_dir(path)
            else:
                return Result.error('missing repo: %s' % path)


class FlatterFrame(tk.Frame):
    def __init__(self, parent=None):
        tk.Frame.__init__(self, parent)

        self.pack(expand=tk.YES, fill=tk.BOTH)            # make me expandable

        self.init_canvas()

    def init_canvas(self):
        canvas = tk.Canvas(self, bg='dark grey')
        # canvas.config(scrollregion=(0, 0, 500, 500))      # canvas size corners
        canvas.config(highlightthickness=0)               # no pixels to border

        vertical = tk.Scrollbar(self)
        vertical.config(command=canvas.yview)             # xlink sbar and canv
        canvas.config(yscrollcommand=vertical.set)        # move one moves other
        vertical.pack(side=tk.RIGHT, fill=tk.Y)           # pack first=clip last

        horizontal = tk.Scrollbar(self, orient=tk.HORIZONTAL)
        horizontal.config(command=canvas.xview)           # xlink sbar and canv
        canvas.config(xscrollcommand=horizontal.set)      # move one moves other
        horizontal.pack(side=tk.BOTTOM, fill=tk.X)        # pack first=clip last

        canvas.pack(side=tk.LEFT, expand=tk.YES, fill=tk.BOTH) # canv clipped first

        self.canvas = canvas


class FlatterWin:
    def __init__(self, root=None):
        if root is None:
            root = tk.Tk()
        self.root = root
        self.flatter = Flatter()

        root.wm_title('Flatter!')

        w = root.winfo_screenwidth() / 2
        h = root.winfo_screenheight() / 2
        root.geometry('%dx%d' % (w, h))

        root.protocol('WM_DELETE_WINDOW', self.on_destroy)

        self.init_menu()

        FlatterFrame(root)

        root.mainloop()

    def on_destroy(self):
        self.root.destroy()
        sys.exit()

    def init_menu(self):
        menu_bar = tk.Menu(self.root)
        file_menu = tk.Menu(menu_bar, tearoff=0)
        file_menu.add_command(label='Open Repo', command=self.ask_open_dir)
        open_recents_menu = tk.Menu(file_menu, tearoff=0)
        file_menu.add_cascade(label='Open Recent', menu=open_recents_menu)
        file_menu.add_command(
            label='Refresh', command=self.refresh_repo, state='disabled')
        file_menu.add_separator()
        file_menu.add_command(label='Exit', command=self.on_destroy)

        menu_bar.add_cascade(label='File', menu=file_menu)

        self.root.config(menu=menu_bar)
        self.file_menu = file_menu
        self.open_recents_menu = open_recents_menu

        self.update_open_recent_menu()

    def update_open_recent_menu(self):
        self.open_recents_menu.delete(0, 'end')

        recents = self.flatter.get_recent_paths()
        state = 'normal' if recents else 'disabled'
        self.file_menu.entryconfig('Open Recent', state=state)

        if not recents:
            return

        # generator fn to correcty capture value of "recent" in closure
        def make_cmd():
            recent2 = recent
            return lambda: self.open_dir(recent2, from_recent=True)

        for recent in recents:
            self.open_recents_menu.add_command(
                label=recent,
                command=make_cmd())

    def ask_open_dir(self):
        path = tk.filedialog.askdirectory(
            initialdir=self.flatter.get_last_path())
        if path:
            self.open_dir(path)

    def refresh_repo(self):
        self.open_dir(self.flatter.get_last_path())

    def open_dir(self, path, from_recent=False):
        if not path:
            return

        result = self.flatter.open_dir(path)
        if not result:
            title = 'Couldn\'t open repo'
            if from_recent:
                err_txt = (result.get_err() + '\n\n' +
                    'Remove from recent repos?')
                remove_recent = tk.messagebox.askquestion(
                    title, result.get_err(),
                    icon=tk.messagebox.ERROR)
                if remove_recent == tk.messagebox.YES:
                    self.flatter.remove_recent(path)
            else:
                tk.messagebox.showerror(title, result.get_err())

        self.update_open_recent_menu()
        state = 'normal' if self.flatter.get_is_open() else 'disabled'
        self.file_menu.entryconfig('Refresh', state=state)


if __name__ == '__main__':
    FlatterWin()
