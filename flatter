#!/usr/bin/env python3

################################################################################
# The MIT License (MIT)

# Copyright (c) 2020 J. Brian Lee

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
################################################################################

try:
    import tkinter as tk
except ModuleNotFoundError:
    sys.exit('error: tkinter not found. You may need to "pip install tk".')

import collections
import configparser
import os
import pprint
import re
import subprocess
import sys

import tkinter.filedialog
import tkinter.messagebox


class Result:
    def __init__(self, val=None, err=None):
        self._val = val
        self._err = err

    def __bool__(self):
        return not bool(self._err)

    def get_val(self):
        if self._err:
            raise RuntimeError('Getting Result value from error Result')
        return self._val

    def get_err(self):
        return self._err

    def error(err):
        return Result(None, err)


class DoInExistingDir(object):
    def __init__(self, path):
        self._old_dir = os.getcwd()
        self._new_dir = path

    def __enter__(self):
        try:
            os.chdir(self._new_dir)
            return self
        except:
            return None

    def __exit__(self, type, value, traceback):
        os.chdir(self._old_dir)
        return isinstance(value, OSError)

def exec_proc(cmd, capture_output=True, console=None):
    sys.stdout.flush()
    sys.stderr.flush()

    shell = type(cmd) == str

    if console:
        cmd_txt = cmd if shell else ' '.join(cmd)
        console.write('exec cmd: ' + cmd_txt)

    if capture_output:
        p = subprocess.Popen(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE)
        out, err = p.communicate()
        out = out.decode('utf-8').strip()
        err = err.decode('utf-8').strip()
        return p.returncode, out, err
    else:
        return subprocess.call(cmd, shell=shell)


def is_descendant_of(w, other):
    if not w:
        return False

    if w == other:
        return True

    return is_descendant_of(w.master, other)


def get_lines(text):
    lines = text.split('\n') if text else []
    # lines = [line.strip() for line in lines]
    return lines


def get_home_dir():
    # posix
    if 'HOME' in os.environ:
        return os.environ['HOME']
    # windows
    elif 'HOMEPATH' in os.environ:
        drive = os.environ['HOMEDRIVE'] if 'HOMEDRIVE' in os.environ else ''
        path = os.environ['HOMEPATH']
        return os.path.join(drive, path)
    # ???
    else:
        return os.path.abspath('.')


def make_git_err_msg(cmd, out, err):
    if type(cmd) == list:
        cmd = ' '.join(cmd)
    err_str = \
        'git cmd failed: \"' + cmd + '\"\n' \
        '  out: ' + out + '\n' \
        '  err: ' + err
    return Result.error(err_str)


def get_git_hash(ref):
    cmd = ['git', 'rev-parse', ref]
    (ret, out, err) = exec_proc(cmd)
    if ret == 0:
        return Result(out.strip())
    else:
        return make_git_err_msg(cmd, out, err)


def get_submodule_status(cached, console=None):
    cmd = 'git submodule status --recursive'
    if cached:
        cmd += ' --cached'
    (ret, out, err) = exec_proc(cmd, console=console)
    if ret == 0:
        return Result(get_lines(out.strip()))
    else:
        return make_git_err_msg(cmd, out, err)


def get_git_remotes(console=None):
    cmd = 'git remote'
    (ret, out, err) = exec_proc(cmd, console=console)
    if ret == 0:
        return Result(get_lines(out.strip()))
    else:
        return make_git_err_msg(cmd, out, err)


def fetch_git_remote(remote, console=None):
    cmd = ['git', 'fetch', remote]
    (ret, out, err) = exec_proc(cmd, console=console)
    if ret == 0:
        return Result()
    else:
        return make_git_err_msg(cmd, out, err)


class Submodule:
    def __init__(self,
        name, path,
        indexed_hash, checked_out_hash,
        indexed_descr, checked_out_descr,
        initialized, merge_conflicts):

        self.name = name
        self.path = path
        self.indexed_hash = indexed_hash
        self.checked_out_hash = checked_out_hash
        self.indexed_descr = indexed_descr
        self.checked_out_descr = checked_out_descr
        self.initialized = initialized
        self.merge_conflicts = merge_conflicts
        self.subs = []

    def add_sub(self, sub):
        self.subs.append(sub)


class Flatter:
    def __init__(self, console):
        self._is_open = False
        self._home_dir = get_home_dir()
        self._last_path = self._home_dir
        self._recent_paths = []
        self._root_sub = self.create_root_sub()
        self._console = console
        self.read_config()

    def write_console(self, text):
        if self._console:
            self._console.write(text)
        else:
            print(text)

    def get_is_open(self):
        return self._is_open

    def create_root_sub(self):
        return Submodule(
            name='', path='',
            indexed_hash='', checked_out_hash='',
            indexed_descr='', checked_out_descr='',
            initialized=False, merge_conflicts=False)

    def get_last_path(self):
        return self._last_path

    def set_last_path(self, path):
        if not path:
            return

        self._last_path = path
        if path in self._recent_paths:
            self._recent_paths.remove(path)
        self._recent_paths.insert(0, path)
        self._recent_paths = self._recent_paths[:20]

    def get_recent_paths(self):
        return self._recent_paths[:]

    def get_root_sub(self):
        return self._root_sub

    def get_sub_depth(self):
        def do_get_sub_depth(sub):
            if len(sub.subs) == 0:
                return 0
            return max([do_get_sub_depth(child) for child in sub.subs]) + 1

        return do_get_sub_depth(self._root_sub)

    def remove_recent(self, path):
        if path in self._recent_paths:
            self._recent_paths.remove(path)
            self.write_config()

    def read_config(self):
        if not self._home_dir:
            return

        cfg_file_name = os.path.join(self._home_dir, '.flatter')
        config = configparser.ConfigParser()
        config.read(cfg_file_name)

        if config.has_section('paths'):
            self._last_path = config.get(
                'paths', 'last_path', fallback=self._last_path)

            recents = [item for item in config.items('paths')
                if item[0].startswith('recent_path_')]
            recents.sort(key=lambda pair : pair[0])
            self._recent_paths = [item[1] for item in recents]

    def write_config(self):
        if not self._home_dir:
            return

        paths = collections.OrderedDict()
        if self._last_path:
            paths['last_path'] = self._last_path

        idx = 0
        for recent_path in self._recent_paths:
            key = 'recent_path_%02d' % idx
            paths[key] = recent_path
            idx += 1

        cfg = collections.OrderedDict()
        cfg['paths'] = paths

        config = configparser.ConfigParser()
        config.read_dict(cfg)

        cfg_file_name = os.path.join(self._home_dir, '.flatter')
        with open(cfg_file_name, 'w') as configfile:
            config.write(configfile)

    def insert_new_sub(self, root_sub, new_sub):
        for sub in root_sub.subs:
            if new_sub.path.startswith(sub.path + '/'):
                self.insert_new_sub(sub, new_sub)
                return
        self.write_console('adding sub: %s' % new_sub.name)
        root_sub.add_sub(new_sub)

    def build_submodule_tree(self):
        result = get_submodule_status(cached=True, console=self._console)
        if not result:
            return result
        indexed_subs = result.get_val()

        result = get_submodule_status(cached=False, console=self._console)
        if not result:
            return result
        checked_out_subs = result.get_val()

        if len(indexed_subs) != len(checked_out_subs):
            return Result.error(
                'indexed and checked out submodule lists were not the ' \
                'same length')

        root_sub = self.create_root_sub()

        i = 0
        while i < len(indexed_subs):
            indexed_sub = indexed_subs[i]
            checked_out_sub = checked_out_subs[i]
            if not indexed_sub:
                return Result.error('indexed submodule line was empty')
            if not checked_out_sub:
                return Result.error('checked out submodule line was empty')
            if indexed_sub[0] != checked_out_sub[0]:
                return Result.error(
                    'submodule lines aren\' compatible; ' \
                    'first characters must match.\n' \
                    '    indexed: %s\n' \
                    'checked out: %s\n' % \
                    (indexed_sub, checked_out_sub))

            initialized = indexed_sub[0] != '-'
            merge_conflicts = indexed_sub[0] != 'U'

            indexed_sub = indexed_sub[1:].split(' ')
            checked_out_sub = checked_out_sub[1:].split(' ')

            if len(indexed_sub) < 2:
                return Result.error('indexed submodule line too short')
            if len(checked_out_sub) < 2:
                return Result.error('checked out submodule line too short')

            indexed_hash = indexed_sub[0]
            checked_out_hash = checked_out_sub[0]

            if indexed_sub[1] != checked_out_sub[1]:
                return Result.error(
                    'sub paths didn\'t match:\n' \
                    '  "%s" != "%s"' % (indexed_sub[1], checked_out_sub[1]))

            sub_path = indexed_sub[1]
            sub_name = os.path.basename(sub_path)

            indexed_descr = ''
            if len(indexed_sub) >= 3:
                indexed_descr = indexed_sub[2]
                indexed_descr = re.sub(r'^\(', '', indexed_descr)
                indexed_descr = re.sub(r'\)$', '', indexed_descr)

            checked_out_descr = ''
            if len(checked_out_sub) >= 3:
                checked_out_descr = checked_out_sub[2]
                checked_out_descr = re.sub(r'^\(', '', checked_out_descr)
                checked_out_descr = re.sub(r'\)$', '', checked_out_descr)

            new_sub = Submodule(
                name=sub_name,
                path=sub_path,
                indexed_hash=indexed_hash,
                checked_out_hash=checked_out_hash,
                indexed_descr=indexed_descr,
                checked_out_descr=checked_out_descr,
                initialized=initialized,
                merge_conflicts=merge_conflicts)
            self.insert_new_sub(root_sub, new_sub)

            i += 1

        self._root_sub = root_sub;

        return Result()

    def do_open_dir(self, path):
        if not path or not type(path) is str:
            return Result.error('bad path: "%s"' % str(path))

        git_status_cmd = 'git status'
        (ret, out, err) = exec_proc(git_status_cmd)
        if ret != 0:
            return Result.error(err)

        lines = get_lines(out)
        if not lines:
            err_txt = 'git status didn\'t return anything in path: %s' % path
            return Result.error(err_txt)

        detatched_marker = 'HEAD detached at '
        branch_marker = 'On branch '
        if lines[0].startswith(detatched_marker):
            branch = lines[0]
            commit = lines[0][len(detatched_marker):]
        elif lines[0].startswith(branch_marker):
            branch = lines[0][len(branch_marker):]
            commit_result = get_git_hash('HEAD')
            if not commit_result:
                return commit_result
            commit = commit_result.get_val()
        else:
            err_txt = (
                'bad git output:\n' +
                '  out: %s\n' +
                '  err: %s\n') % out, err
            return make_git_err_msg(git_status_cmd, out, err)

        self.write_console(
            'successfully opened path: %s\n'
            '  branch: %s\n'
            '  commit: %s\n' %
            (path, branch, commit))

        result = self.build_submodule_tree()
        if result:
            self._is_open = True
            self.set_last_path(path)
            self.write_config()

        return result

    def open_dir(self, path):
        with DoInExistingDir(path) as ctx:
            if ctx:
                return self.do_open_dir(path)
            else:
                return Result.error('missing repo: %s' % path)

    def fetch_submodule(self):
        result = get_git_remotes(console=self._console)
        if not result:
            self._console.write(
                'Error getting remotes for submodule:\n'
                '  %s' % result.get_err())
            return result

        remotes = result.get_val()
        if remotes:
            self._console.write('Found remote(s): ' + ', '.join(remotes))
        else:
            self._console.write('Found no remotes.')

        had_err = False
        for remote in remotes:
            result = fetch_git_remote(remote, console=self._console)
            if not result:
                had_err = True
                self._console.write(
                    'Error fetching submodule:\n'
                    '  %s' % result.get_err())

        return Result() if not had_err else Result('Error fetching submodule')

    def fetch_immediate_submodules(self):
        if not self._is_open:
            return

        had_err = False
        for sub in self._root_sub.subs:
            path = os.path.join(self._last_path, sub.path)
            self._console.write('Entering directory: ' + path)
            with DoInExistingDir(path) as ctx:
                if ctx:
                    if not self.fetch_submodule():
                        had_err = True
                else:
                    had_err = True
                    self._console.write(
                        'Could not switch to directory %s '
                        'for submodule %s\n' % (sub.path, sub.name))

        return (Result() if not had_err else
            Result.error('Errors encountered fetching submodules.'))


class SubmodFrame(tk.Frame):
    def __init__(self, submodule, *args, **kwargs):
        super(SubmodFrame, self).__init__(*args, **kwargs)
        self.submodule = submodule

        parent = args[0]
        self['bg'] = parent['bg']

        data_frame = tk.Frame(self,
            bg='light grey',
            highlightbackground='black',
            highlightthickness=1)

        def make_label(text):
            var = tk.StringVar()
            var.set(text)
            label = tk.Label(data_frame, textvariable=var)
            label['bg'] = data_frame['bg']
            label.pack(anchor=tk.W)

        make_label('Submodule: ' + submodule.name)
        make_label('Path: ' + submodule.path)

        indexed_str = 'At index: ' + submodule.indexed_hash[:8]
        if submodule.indexed_descr:
            indexed_str += ' (%s)' % submodule.indexed_descr
        make_label(indexed_str)

        checked_out_str = 'Checked out: '
        if submodule.initialized:
            checked_out_str += submodule.checked_out_hash[:8]
            if submodule.checked_out_descr:
                checked_out_str += ' (%s)' % submodule.checked_out_descr
        else:
            checked_out_str += '[uninitialized]'
        make_label(checked_out_str)

        data_frame.pack(anchor='nw')

        left_spacer_frame = tk.Frame(self, bg=self['bg'], width=25)
        left_spacer_frame.pack(side=tk.LEFT)

        subs_frame = tk.Frame(self, bg=self['bg'])
        subs_frame.pack(anchor='nw')

        for child in submodule.subs:
            frm = SubmodFrame(child, subs_frame)

        self.pack(anchor='nw', pady=(20, 0))


class GraphFrame(tk.Frame):
    def __init__(self, parent=None):
        tk.Frame.__init__(self, parent)

        self.flatter = None
        self.submod_frames = []

        self.init_canvas()

    def init_canvas(self):
        canvas = tk.Canvas(self, bg='dark grey')
        canvas.config(highlightthickness=0)

        main_frm = tk.Frame(canvas, bg=canvas['bg'], padx=20)
        main_frm.bind(
            "<Configure>",
            lambda e: canvas.configure(
                scrollregion=canvas.bbox("all")
            )
        )
        canvas.create_window((0, 0), window=main_frm, anchor="nw")

        vertical = tk.Scrollbar(self)
        vertical.config(command=canvas.yview)             # xlink sbar and canv
        canvas.config(yscrollcommand=vertical.set)        # move one moves other
        vertical.pack(side=tk.RIGHT, fill=tk.Y)           # pack first=clip last

        horizontal = tk.Scrollbar(self, orient=tk.HORIZONTAL)
        horizontal.config(command=canvas.xview)           # xlink sbar and canv
        canvas.config(xscrollcommand=horizontal.set)      # move one moves other
        horizontal.pack(side=tk.BOTTOM, fill=tk.X)        # pack first=clip last

        canvas.pack(side=tk.LEFT, expand=tk.YES, fill=tk.BOTH)

        self.canvas = canvas
        self.main_frm = main_frm

    def on_mousewheel(self, event):
        if not is_descendant_of(event.widget, self):
            return False

        delta = 1 if event.delta > 0 else -1
        self.canvas.yview_scroll(-delta, 'units')
        return True

    def update_ui(self, flatter):
        for submod_frame in self.submod_frames:
            submod_frame.destroy()
        self.submod_frames = []

        self.flatter = flatter
        root_sub = flatter.get_root_sub()

        for sub in root_sub.subs:
            frm = SubmodFrame(sub, self.main_frm)
            self.submod_frames.append(frm)


class FlatterWinConsole:
    def __init__(self, win):
        self.win = win

    def write(self, text):
        self.win.add_to_console(text)


class FlatterWin:
    def __init__(self, root=None):
        if root is None:
            root = tk.Tk()
            root['bg'] = 'light grey'
        bg_color = root['bg']
        self.root = root
        self.flatter = Flatter(FlatterWinConsole(self))

        root.wm_title('Flatter!')

        w = root.winfo_screenwidth() / 2
        h = root.winfo_screenheight() / 2
        root.geometry('%dx%d' % (w, h))

        root.protocol('WM_DELETE_WINDOW', self.on_destroy)

        self.init_menu()

        button_frame = tk.Frame(root, bg=bg_color)
        button_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)

        fetch_top_subs_btn = tk.Button(button_frame,
            text='Fetch Immediate\nSubmodules',
            command=self.fetch_immediate_submodules)
        fetch_top_subs_btn.pack(side=tk.TOP)

        pane1 = tk.PanedWindow(
            orient=tk.VERTICAL, sashwidth=10, sashrelief=tk.SUNKEN,
            showhandle=True)
        pane1.pack(fill=tk.BOTH, expand=True)

        self.graph_frame = GraphFrame(pane1)

        console_frame = tk.Frame(pane1)

        self.console_scrollbar = tk.Scrollbar(console_frame)
        self.console = tk.Text(console_frame, bg=bg_color)
        self.console_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.console.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.console_scrollbar.config(command=self.console.yview)
        self.console.config(yscrollcommand=self.console_scrollbar.set)

        pane1.update()
        pane_height = pane1.winfo_height()
        top_height = max(pane_height - 100, 100)
        pane1.add(self.graph_frame, height=top_height)
        pane1.add(console_frame, height=100)

        def on_mousewheel(event):
            possible_handlers = [self.graph_frame]
            for w in possible_handlers:
                if w.on_mousewheel(event):
                    return

        root.bind_all("<MouseWheel>", on_mousewheel)
        root.bind_all("<Button-4>", on_mousewheel)
        root.bind_all("<Button-5>", on_mousewheel)

        root.after(50, lambda: self.open_dir('D:/code/flatter/test_repos/blee/app1')) # jbltemp

        root.mainloop()

    def on_destroy(self):
        self.root.destroy()
        sys.exit()

    def init_menu(self):
        menu_bar = tk.Menu(self.root)
        file_menu = tk.Menu(menu_bar, tearoff=0)
        file_menu.add_command(label='Open Repo', command=self.ask_open_dir)
        open_recents_menu = tk.Menu(file_menu, tearoff=0)
        file_menu.add_cascade(label='Open Recent', menu=open_recents_menu)
        file_menu.add_command(
            label='Refresh', command=self.refresh_repo, state='disabled')
        file_menu.add_separator()
        file_menu.add_command(label='Exit', command=self.on_destroy)

        menu_bar.add_cascade(label='File', menu=file_menu)

        self.root.config(menu=menu_bar)
        self.file_menu = file_menu
        self.open_recents_menu = open_recents_menu

        self.update_open_recent_menu()

    def update_open_recent_menu(self):
        self.open_recents_menu.delete(0, 'end')

        recents = self.flatter.get_recent_paths()
        state = 'normal' if recents else 'disabled'
        self.file_menu.entryconfig('Open Recent', state=state)

        if not recents:
            return

        # generator fn to correcty capture value of "recent" in closure
        def make_cmd():
            recent2 = recent
            return lambda: self.open_dir(recent2, from_recent=True)

        for recent in recents:
            self.open_recents_menu.add_command(
                label=recent,
                command=make_cmd())

    def ask_open_dir(self):
        path = tk.filedialog.askdirectory(
            initialdir=self.flatter.get_last_path())
        if path:
            self.open_dir(path)

    def refresh_repo(self):
        self.open_dir(self.flatter.get_last_path())

    def open_dir(self, path, from_recent=False):
        if not path:
            return

        result = self.flatter.open_dir(path)
        if not result:
            self.add_to_console(
                '====== ERROR ======\n' +
                result.get_err() + '\n' +
                '  ==== END ERROR ====')

            title = 'Error'
            err_txt = \
                'Couldn\'t open repo.\n' \
                '(See console for additional information.)'
            if from_recent:
                err_txt += '\n\nRemove from recent repos?'
                remove_recent = tk.messagebox.askquestion(
                    title, err_txt,
                    icon=tk.messagebox.ERROR)
                if remove_recent == tk.messagebox.YES:
                    self.flatter.remove_recent(path)
            else:
                tk.messagebox.showerror(title, err_txt)

        self.update_open_recent_menu()
        state = 'normal' if self.flatter.get_is_open() else 'disabled'
        self.file_menu.entryconfig('Refresh', state=state)

        if result:
            self.graph_frame.update_ui(self.flatter)

    def clear_console(self):
        self.console['state'] = tk.NORMAL
        self.console.delete(1.0, tk.END)
        self.console['state'] = tk.DISABLED

    def add_to_console(self, text):
        self.console['state'] = tk.NORMAL
        do_scroll = self.console_scrollbar.get()[1] == 1
        self.console.insert(tk.END, '> %s\n' % text)
        if do_scroll:
            self.console.see(tk.END)
        self.console['state'] = tk.DISABLED

    def fetch_immediate_submodules(self):
        self.flatter.fetch_immediate_submodules()

if __name__ == '__main__':
    FlatterWin()
